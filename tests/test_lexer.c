/**
 * Standalone Lexer Tester
 *
 * This program compiles the lexer and a dummy parser, then
 * feeds input to the lexer to print a stream of tokens.
 *
 * How to compile (using the Makefile):
 * $ make test_lexer
 *
 * How to run:
 * $ ./bin/test_lexer < my_formula.txt
 * or
 * $ echo "=SUM(A1:B10) + 10.5" | ./bin/test_lexer
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*
 * parser.tab.h is generated by Bison and contains:
 * 1. All the token definitions (e.g., NUMBER, PLUS)
 * 2. The YYSTYPE union definition
 */
#include "parser.tab.h"

/* --- Function Prototypes --- */
void print_token_table_header();
void print_token_table_row(int line, int col, const char* type, const char* value);
void print_token_table_footer();
const char* get_token_value(int token_type, YYSTYPE yylval);
const char* get_token_name(int token_type); // <-- FIX: Added prototype

/* --- Global Variables --- */
/* These are defined by lex/yacc */
extern int yylex();
extern char* yytext;
extern int yylineno;     // Line number (managed by %option yylineno)
extern FILE* yyin;       // Input stream

/*
 * THE FIX IS HERE:
 * This was: YYSTYPE yylval;
 * We change it to 'extern' to declare it, not define it.
 * The 'parser.tab.c' file (from parser.y) is responsible
 * for the actual definition.
 */
extern YYSTYPE yylval;

/* --- Main Program --- */
int main(int argc, char** argv) {
    int token;
    int token_count = 0;
    int current_line = 1;

    // TODO: Add column tracking in the lexer
    int current_col = 1;

    // Check for file input
    if (argc > 1) {
        FILE* input_file = fopen(argv[1], "r");
        if (!input_file) {
            perror("Error opening file");
            return 1;
        }
        // Point yyin (flex's input) to our file
        yyin = input_file;
    }
    // If no file, flex defaults to stdin (piped input)

    print_token_table_header();

    // yylex() returns 0 at EOF
    while ((token = yylex())) {
        token_count++;

        // Get the string name of the token (e.g., "NUMBER", "PLUS")
        const char* token_name = get_token_name(token); // <-- This will now work

        // Get the value (e.g., "10.5", "A1")
        const char* token_value = get_token_value(token, yylval);

        // yylineno is automatically tracked by flex
        print_token_table_row(yylineno, current_col, token_name, token_value);

        // Simple column tracking (reset on new line)
        if (yylineno > current_line) {
            current_line = yylineno;
            current_col = 1; // Reset column (this is an approximation)
        } else {
            // A basic approximation for column
            if (yytext) {
                current_col += strlen(yytext);
            }
        }

        // Free memory if strdup was used (for strings, cells, ranges)
        if (token == CELL_REF || token == RANGE || token == STRING || token == ERROR) {
            if (yylval.str) {
                free(yylval.str);
                yylval.str = NULL; // Avoid double-free
            }
        }

        if (token == 0 || token == EOF || token == ERROR) {
            // yylex() returns 0 on EOF
            break; // Stop on error or end
        }
    }

    print_token_table_footer();
    printf("\nTotal Tokens: %d\n", token_count);

    if (yyin) {
        fclose(yyin);
    }

    return 0;
}

/* --- Helper Functions --- */

/**
 * @brief Gets a printable string for the token's value.
 * @param token_type The token enum (e.g., NUMBER, CELL_REF)
 * @param yylval The yylval union containing the value
 * @return A constant string or a static buffer string.
 */
const char* get_token_value(int token_type, YYSTYPE lval) {
    // Use a static buffer to hold the string representation of numbers
    // This is not re-entrant, but fine for this single-threaded tester.
    static char num_buffer[64];

    switch (token_type) {
        case NUMBER:
            // Store the double as a string
            snprintf(num_buffer, sizeof(num_buffer), "%.10g", lval.num);
            return num_buffer;

        case CELL_REF:
        case RANGE:
        case STRING:
        case ERROR:
            // These types store a char* in yylval.str
            return lval.str ? lval.str : "(null)";

        // These tokens have their value implied by their type
        // (but get_token_name is preferred)
        case SUM: return "SUM";
        case AVERAGE: return "AVERAGE";
        case MIN: return "MIN";
        case MAX: return "MAX";
        case IF: return "IF";
        case AND: return "AND";
        case OR: return "OR";
        case NOT: return "NOT";
        case PLUS: return "+";
        case MINUS: return "-";
        case MULTIPLY: return "*";
        case DIVIDE: return "/";
        case POWER: return "^";
        case LPAREN: return "(";
        case RPAREN: return ")";
        case EQUALS: return "=";
        case COMMA: return ",";
        case COLON: return ":";
        case GT: return ">";
        case LT: return "<";
        case GTE: return ">=";
        case LTE: return "<=";
        case NE: return "<>";
        case EOF: return "EOF";

        default:
            // For single-char tokens that we didn't list
            // yylex() often returns the char code itself.
            if (token_type > 0 && token_type < 256) {
                snprintf(num_buffer, sizeof(num_buffer), "%c", (char)token_type);
                return num_buffer;
            }
            return "---";
    }
}

/**
 * @brief Converts a token type (int) into a human-readable string name.
 * @param token_type The token enum (e.g., NUMBER, PLUS)
 * @return A constant string (e.g., "NUMBER", "PLUS")
 */
const char* get_token_name(int token_type) {
    // This switch uses the token names defined in parser.tab.h
    switch (token_type) {
        // Literals
        case NUMBER: return "NUMBER";
        case STRING: return "STRING";
        case CELL_REF: return "CELL_REF";
        case RANGE: return "RANGE";

        // Functions
        case SUM: return "SUM";
        case AVERAGE: return "AVERAGE";
        case MIN: return "MIN";
        case MAX: return "MAX";
        case IF: return "IF";
        case AND: return "AND";
        case OR: return "OR";
        case NOT: return "NOT";

        // Operators
        case PLUS: return "PLUS";
        case MINUS: return "MINUS";
        case MULTIPLY: return "MULTIPLY";
        case DIVIDE: return "DIVIDE";
        case POWER: return "POWER";

        // Comparison
        case GT: return "GT";
        case LT: return "LT";
        case GTE: return "GTE";
        case LTE: return "LTE";
        case NE: return "NE";

        // Delimiters
        case LPAREN: return "LPAREN";
        case RPAREN: return "RPAREN";
        case EQUALS: return "EQUALS";
        case COMMA: return "COMMA";
        case COLON: return "COLON";

        // Special
        case ERROR: return "ERROR";
        case 0: // yylex returns 0 on EOF
        case EOF:
            return "EOF";

        default:
            // For any single-char tokens (like '+', '-', '(', etc.)
            // that might be returned directly without a %token name.
            if (token_type > 0 && token_type < 256) {
                return "CHAR_LITERAL";
            }
            return "UNKNOWN";
    }
}


void print_token_table_header() {
    printf("\nTOKEN STREAM ANALYSIS\n");
    printf("=================================================================\n");
    printf("%-5s | %-5s | %-15s | %s\n", "Line", "Col", "Token Type", "Value");
    printf("------|-------|-----------------|------------------------------\n");
}

void print_token_table_row(int line, int col, const char* type, const char* value) {
    // A simple way to approximate column tracking
    // A real implementation would be done in the lexer.
    static int last_line = 1;
    static int last_col = 1;

    if (line > last_line) {
        last_line = line;
        last_col = 1;
    }

    printf("%-5d | %-5d | %-15s | %s\n", line, last_col, type, value);

    // This is a very basic approximation of column tracking
    if (value) {
        last_col += strlen(value);
        if (strcmp(value, "+") == 0 || strcmp(value, "-") == 0 ||
            strcmp(value, "*") == 0 || strcmp(value, "/") == 0 ||
            strcmp(value, "=") == 0 || strcmp(value, "(") == 0 ||
            strcmp(value, ")") == 0 || strcmp(value, ",") == 0 ||
            strcmp(value, ":") == 0 || strcmp(value, ">") == 0 ||
            strcmp(value, "<") == 0)
            {
                last_col += 2; // Add spacing for operators
            } else {
                last_col += 1; // Add 1 space
            }
    }
}

void print_token_table_footer() {
    printf("=================================================================\n");
}

